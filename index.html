<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Get today's beans ‚Äî mobile</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{--card:#0c1330;--accent:#3b82f6;--ink:#fff}
  html,body{margin:0;height:100%;background:#0e1020;color:var(--ink);font-family:system-ui,Arial}
  .page{min-height:100svh;display:grid;place-items:center;padding:12px}
  .gamewrap{position:relative;display:flex;align-items:center;justify-content:center}
  #game{background:var(--card);border:2px solid var(--accent);border-radius:16px;
        box-shadow:0 12px 30px rgba(0,0,0,.4);touch-action:none}
  .hud{position:absolute;top:8px;left:50%;transform:translateX(-50%);display:flex;gap:14px;
       font-weight:700;background:rgba(0,0,0,.18);padding:6px 10px;border-radius:999px;z-index:3}

  /* Overlays */
  .overlay{position:absolute;inset:0;display:grid;place-items:center;z-index:5;
           color:#e6efff;text-align:center;text-shadow:0 2px 6px rgba(0,0,0,.6)}
  .overlay-bg{position:absolute;inset:0;background:linear-gradient(transparent, rgba(0,0,0,.25) 40%, rgba(0,0,0,.35))}
  .start .pill{position:relative;background:rgba(0,0,0,.35);border:1px solid #1b2557;border-radius:999px;
               padding:10px 16px;font-weight:800}
  .winbox{position:relative;background:rgba(0,0,0,.45);border:1px solid #1b2557;border-radius:16px;
          padding:12px 12px 14px;display:flex;flex-direction:column;gap:8px;align-items:center}
  .winbox img{max-width:min(78vw, 360px);height:auto;border-radius:12px;display:block}
  .winbox figcaption{margin-top:4px;font-weight:800;letter-spacing:.3px}
  .btn{background:var(--accent);border:none;color:#fff;padding:10px 16px;border-radius:999px;cursor:pointer}

  .hidden{display:none !important;}

  /* Controls INSIDE the display (bottom-center) */
  .touch-controls{position:absolute;left:0;right:0;bottom:10px;display:flex;justify-content:center;
                  gap:12px;padding:0 10px;pointer-events:none;z-index:3}
  .tc-group{display:flex;gap:12px;pointer-events:auto}
  .tc-btn{
    min-width:clamp(52px,13vw,72px);min-height:clamp(52px,13vw,72px);
    border-radius:14px;border:1px solid #1b2557;background:linear-gradient(#0f1536,#0c1330);
    color:#cfe3ff;font-weight:700;display:flex;align-items:center;justify-content:center;
    user-select:none;touch-action:none
  }
  .tc-btn:active{transform:scale(.98)}
  .tc-fire{min-width:clamp(74px,21vw,106px)}
  @media (prefers-reduced-motion:reduce){ .tc-btn{transition:none} }
</style>
</head>
<body>
  <div class="page">
    <div class="gamewrap" aria-label="Game area">
      <div class="hud">
        <div>Beans: <span id="beans">0</span></div>
        <div>Lives: <span id="lives">3</span></div>
      </div>

      <!-- Canvas -->
      <canvas id="game" width="480" height="720" aria-label="Bjorn Beans canvas"></canvas>

      <!-- Start overlay -->
      <div id="startOverlay" class="overlay start">
        <div class="overlay-bg"></div>
        <div class="pill">Click here to start</div>
      </div>

      <!-- Win overlay (GIF + footer + play again) -->
      <div id="winOverlay" class="overlay hidden" aria-live="polite">
        <div class="overlay-bg"></div>
        <figure class="winbox">
          <img id="winGif" src="" alt="Well done animation" />
          <figcaption>Well done!!</figcaption>
          <button id="playAgain" class="btn">Play again</button>
        </figure>
      </div>

      <!-- Controls INSIDE the display -->
      <div id="touchControls" class="touch-controls">
        <div class="tc-group">
          <button id="btnLeft"  class="tc-btn" aria-label="Move left">‚¨ÖÔ∏è</button>
          <button id="btnRight" class="tc-btn" aria-label="Move right">‚û°Ô∏è</button>
        </div>
        <div class="tc-group">
          <button id="btnFire"  class="tc-btn tc-fire" aria-label="Fire">üî• FIRE</button>
        </div>
      </div>
    </div>
  </div>

<script>
/* ==================== CONFIG ==================== */
const BASE_W = 480, BASE_H = 720;          // logical game size
const VERSION = "v14";                      // bump to bust cache on Pages
const PLAYER_IMG_SRC = `./ship.png?${VERSION}`;
const WIN_GIF_SRC   = `./well-done.gif?${VERSION}`; // <-- upload this file

const BASE_SHIP_HEIGHT = 112;               // slightly smaller
const BASE_BEAN_W = 22, BASE_BEAN_H = 34;
const ENEMY_BASE_W = 24, ENEMY_BASE_H = 20;
const ENEMY_SCALE  = 1.45;
const ENEMY_COLS = 7, ENEMY_ROWS = 3;

/* Optional external images (leave "" to use built-in SVGs) */
const BEAN_IMG_SRC  = "";
const ALIEN_IMG_SRC = "";

/* ============== Canvas (HiDPI + responsive) ============== */
const c = document.getElementById('game');
const g = c.getContext('2d');
const touchControls = document.getElementById('touchControls');
const startOverlay  = document.getElementById('startOverlay');
const winOverlay    = document.getElementById('winOverlay');
const winGifEl      = document.getElementById('winGif');
const playAgainBtn  = document.getElementById('playAgain');

let scaleCSS = 1, dpr = 1, SAFE_BOTTOM = 100;

/** Fit canvas by both width & height, then reserve bottom area for in-canvas controls */
function resizeCanvas(){
  const vw = window.innerWidth, vh = window.innerHeight;
  const margin = 12;
  const availW = Math.max(320, vw - margin*2);
  const availH = Math.max(360, vh - margin*2);

  const scaleByW = availW / BASE_W;
  const scaleByH = availH / BASE_H;
  const MIN_SCALE = 0.40, MAX_SCALE = 0.90;   // overall smaller feel
  scaleCSS = Math.max(MIN_SCALE, Math.min(MAX_SCALE, Math.min(scaleByW, scaleByH)));

  const cssW = Math.round(BASE_W * scaleCSS);
  const cssH = Math.round(BASE_H * scaleCSS);
  c.style.width  = cssW + 'px';
  c.style.height = cssH + 'px';

  dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  c.width  = Math.round(BASE_W * dpr);
  c.height = Math.round(BASE_H * dpr);
  g.setTransform(dpr, 0, 0, dpr, 0, 0);

  const ctrlH_css = touchControls.getBoundingClientRect().height || 110;
  SAFE_BOTTOM = Math.round((ctrlH_css / cssH) * BASE_H) + 8;

  recalcSpriteSizes();
}
addEventListener('resize', resizeCanvas);

/* ==================== Inputs ==================== */
const keys = {};
addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  if (e.code === 'Space') e.preventDefault();
}, {passive:false});
addEventListener('keyup',   e => keys[e.key.toLowerCase()] = false);

/* Start overlay actions */
function hideStart(){ startOverlay.classList.add('hidden'); }
startOverlay.addEventListener('pointerdown', (e)=>{ e.preventDefault(); if (!S.running) { hideStart(); start(); } }, {passive:false});
addEventListener('keydown', (e)=>{ if (!S.running && !startOverlay.classList.contains('hidden')) { hideStart(); start(); }});

/* Canvas tap/hold shooting */
let touchActiveCanvas = false;
c.addEventListener('pointerdown', (e) => { touchActiveCanvas = true; shoot(); e.preventDefault(); }, { passive:false });
['pointerup','pointercancel','pointerleave','pointerout'].forEach(ev =>
  c.addEventListener(ev, () => { touchActiveCanvas = false; })
);
document.addEventListener('visibilitychange', () => { if (document.hidden) touchActiveCanvas = false; });
addEventListener('blur', () => { touchActiveCanvas = false; });

/* On-screen buttons */
const btnLeft  = document.getElementById('btnLeft');
const btnRight = document.getElementById('btnRight');
const btnFire  = document.getElementById('btnFire');
let leftPressed = false, rightPressed = false, firePressed = false;
function bindHold(btn, setter){
  const down = (e)=>{ setter(true); e.preventDefault(); };
  const up   = (e)=>{ setter(false); e.preventDefault(); };
  btn.addEventListener('pointerdown', down, {passive:false});
  ['pointerup','pointerleave','pointercancel','pointerout'].forEach(ev => btn.addEventListener(ev, up, {passive:false}));
  btn.addEventListener('mousedown', down);
  ['mouseup','mouseleave'].forEach(ev => btn.addEventListener(ev, up));
}
bindHold(btnLeft,  v=> leftPressed  = v);
bindHold(btnRight, v=> rightPressed = v);
bindHold(btnFire,  v=> firePressed  = v);

/* ==================== Assets ==================== */
const shipImg = new Image(); shipImg.src = PLAYER_IMG_SRC;
let shipReady = false, shipW = 64, shipH = 64, shipNatural = {w:64,h:64};
shipImg.onload = () => { shipReady = true; shipNatural.w = shipImg.naturalWidth||64; shipNatural.h = shipImg.naturalHeight||64; recalcSpriteSizes(); };

const beanImg = new Image();
const beanSVG = "<svg xmlns='http://www.w3.org/2000/svg' width='32' height='48' viewBox='0 0 32 48'><defs><linearGradient id='g' x1='0' y='0' x2='0' y2='1'><stop offset='0' stop-color='#7b3f00'/><stop offset='1' stop-color='#b5651d'/></linearGradient></defs><ellipse cx='16' cy='24' rx='10' ry='16' fill='url(#g)'/><ellipse cx='12' cy='16' rx='4' ry='6' fill='rgba(255,255,255,0.25)'/></svg>";
beanImg.src = BEAN_IMG_SRC || ('data:image/svg+xml;utf8,' + encodeURIComponent(beanSVG));
let beanReady = false; beanImg.onload = ()=> beanReady = true;

const alienImg = new Image();
const alienSVG = "<svg xmlns='http://www.w3.org/2000/svg' width='24' height='20' viewBox='0 0 24 20'><rect width='24' height='20' fill='none'/><rect x='2' y='4' width='4' height='2' fill='#7fffd4'/><rect x='18' y='4' width='4' height='2' fill='#7fffd4'/><rect x='4' y='6' width='16' height='6' fill='#7fffd4'/><rect x='6' y='12' width='4' height='2' fill='#7fffd4'/><rect x='14' y='12' width='4' height='2' fill='#7fffd4'/><rect x='8' y='8' width='2' height='2' fill='#001122'/><rect x='14' y='8' width='2' height='2' fill='#001122'/></svg>";
alienImg.src = ALIEN_IMG_SRC || ('data:image/svg+xml;utf8,' + encodeURIComponent(alienSVG));
let alienReady = false; alienImg.onload = ()=> { alienReady = true; };

/* ============== Dynamic sprite sizing ============== */
let BEAN_W = BASE_BEAN_W, BEAN_H = BASE_BEAN_H;
let ALIEN_W = Math.round(ENEMY_BASE_W * ENEMY_SCALE), ALIEN_H = Math.round(ENEMY_BASE_H * ENEMY_SCALE);

function recalcSpriteSizes(){
  const targetH = Math.round(BASE_SHIP_HEIGHT * scaleCSS);
  const s = targetH / (shipNatural.h || BASE_SHIP_HEIGHT);
  shipW = Math.max(24, Math.round((shipNatural.w || BASE_SHIP_HEIGHT) * s));
  shipH = Math.max(24, Math.round((shipNatural.h || BASE_SHIP_HEIGHT) * s));

  BEAN_W = Math.max(10, Math.round(BASE_BEAN_W * scaleCSS));
  BEAN_H = Math.max(16, Math.round(BASE_BEAN_H * scaleCSS));

  const alienBaseW = ENEMY_BASE_W * ENEMY_SCALE;
  const alienBaseH = ENEMY_BASE_H * ENEMY_SCALE;
  ALIEN_W = Math.max(16, Math.round(alienBaseW * scaleCSS));
  ALIEN_H = Math.max(12, Math.round(alienBaseH * scaleCSS));

  // keep player above the controls area
  S.player.w = shipW; S.player.h = shipH;
  S.player.y = BASE_H - (SAFE_BOTTOM + S.player.h/2 + 8);
}

/* ==================== Game state ==================== */
const beansEl = document.getElementById('beans');
const livesEl = document.getElementById('lives');

const S = {
  running:false, beans:0, lives:3, tick:0, wave:0,
  player: { x:BASE_W/2, y:BASE_H-80, w:shipW, h:shipH, speed:4.2, cooldown:0 },
  bullets: [],
  enemies: [],
};

function reset(){
  S.running = true; S.beans = 0; S.lives = 3; S.tick = 0; S.wave = 0;
  S.player.x = BASE_W/2; S.player.cooldown = 0;
  recalcSpriteSizes(); // sets player.y above controls
  S.bullets.length = 0; S.enemies.length = 0;
  spawnWave();
  beansEl.textContent = S.beans; livesEl.textContent = S.lives;
  winOverlay.classList.add('hidden');
}
function endGame(){ S.running = false; startOverlay.classList.remove('hidden'); }

/* Show "win" overlay (after clearing all aliens) */
function showWin(){
  S.running = false;
  winGifEl.src = WIN_GIF_SRC;
  winGifEl.onerror = () => { winGifEl.style.display = 'none'; }; // if GIF missing, just show caption/button
  winOverlay.classList.remove('hidden');
}

/* ==================== Entities ==================== */
function shoot(){
  if (S.player.cooldown > 0) return;
  S.bullets.push({ x:S.player.x - BEAN_W/2, y:S.player.y - S.player.h/2 - BEAN_H + 6, vy:-8, w:BEAN_W, h:BEAN_H });
  S.player.cooldown = 8;
}
function spawnWave(){
  S.wave++;
  const gapX = Math.round(16 * scaleCSS), gapY = Math.round(14 * scaleCSS);
  const totalW = ENEMY_COLS * ALIEN_W + (ENEMY_COLS-1)*gapX;
  const startX = Math.max(10, (BASE_W - totalW)/2);
  const startY = 70;
  for (let r=0;r<ENEMY_ROWS;r++){
    for (let cc=0; cc<ENEMY_COLS; cc++){
      S.enemies.push({
        x: startX + cc*(ALIEN_W + gapX),
        y: startY + r*(ALIEN_H + gapY),
        w: ALIEN_W, h: ALIEN_H, alive: true,
        baseX: startX + cc*(ALIEN_W + gapX),
        baseY: startY + r*(ALIEN_H + gapY),
      });
    }
  }
}

/* ==================== Collisions ==================== */
function rectHit(ax,ay,aw,ah,bx,by,bw,bh){
  return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
}

/* ==================== Loop ==================== */
function update(){
  S.tick++;

  // movement (keyboard + on-screen buttons)
  const leftKey  = keys['arrowleft'] || keys['a'];
  const rightKey = keys['arrowright']|| keys['d'];
  const move = (rightKey || rightPressed ? 1 : 0) - (leftKey || leftPressed ? 1 : 0);
  S.player.x = Math.max(S.player.w/2, Math.min(BASE_W - S.player.w/2, S.player.x + move * S.player.speed));

  // fire (keyboard + canvas hold + fire button)
  const shootKey = keys[' '] || keys['space'];
  if (touchActiveCanvas || firePressed || shootKey) shoot();
  if (S.player.cooldown>0) S.player.cooldown--;

  // bullets
  for(const b of S.bullets){ b.y += b.vy; }
  S.bullets = S.bullets.filter(b => b.y > -60);

  // swarm (sinusoidal + descent)
  const amp = 22 + Math.min(S.tick/10, 46);
  const speed = 0.5 + Math.min(S.tick/600, 1.2);
  for (const e of S.enemies){
    const phase = (e.baseX + e.baseY)*0.01;
    e.x = e.baseX + Math.sin(S.tick*0.03 + phase)*amp;
    e.y = e.baseY + Math.sin(S.tick*0.015 + phase*0.7)*4 + (S.tick*0.02*speed);
    if (e.y + e.h >= S.player.y - 6) { S.lives = 0; livesEl.textContent = S.lives; endGame(); }
  }

  // hits
  for (const b of S.bullets){
    for (const e of S.enemies){
      if (!e.alive) continue;
      if (rectHit(b.x,b.y,b.w,b.h, e.x,e.y,e.w,e.h)){
        e.alive = false; b.y = -9999;
        S.beans += 10; beansEl.textContent = S.beans;
      }
    }
  }
  S.enemies = S.enemies.filter(e => e.alive);

  // WIN: when all aliens are gone, show the GIF overlay instead of spawning a new wave
  if (S.enemies.length === 0 && S.running) { showWin(); }
}

function draw(){
  g.clearRect(0,0,BASE_W,BASE_H);

  // starfield
  g.globalAlpha = .2; g.fillStyle = "#8fb3ff";
  for (let i=0;i<60;i++){ g.fillRect((i*53 + (S.tick*0.6 % 53))%BASE_W, (i*97 + S.tick*0.9)%BASE_H, 2,2); }
  g.globalAlpha = 1;

  // ship
  const p = S.player;
  if (shipReady){ g.drawImage(shipImg, p.x - p.w/2, p.y - p.h/2, p.w, p.h); }
  else { g.fillStyle = "#97e4ff"; g.beginPath(); g.moveTo(p.x, p.y-24); g.lineTo(p.x-20, p.y+22); g.lineTo(p.x+20, p.y+22); g.closePath(); g.fill(); }

  // beans
  for (const b of S.bullets){
    if (beanReady){ g.drawImage(beanImg, b.x, b.y, b.w, b.h); }
    else { g.fillStyle = "#ffd166"; g.fillRect(b.x, b.y, b.w, b.h); }
  }

  // aliens
  for (const e of S.enemies){
    if (alienReady){ g.drawImage(alienImg, e.x, e.y, e.w, e.h); }
    else { g.fillStyle = "#7fffd4"; g.fillRect(e.x, e.y, e.w, e.h); }
  }
}

function loop(){ if (!S.running) return; update(); draw(); requestAnimationFrame(loop); }

/* ==================== Boot ==================== */
function start(){ reset(); loop(); }
resizeCanvas();               // size once
setTimeout(resizeCanvas, 0);  // size again after layout (controls measured)

/* Play again handler */
playAgainBtn.addEventListener('click', () => {
  winOverlay.classList.add('hidden');
  start();
});

// Set GIF source now (so cache-busting applies even before first win)
winGifEl.src = WIN_GIF_SRC;
</script>
</body>
</html>
