<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Tiny Galaxy Shooter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body{margin:0;height:100%;background:#0e1020;color:#fff;font-family:system-ui,Arial}
    #wrap{display:grid;place-items:center;height:100%}
    canvas{background:#0c1330;border:2px solid #3b82f6;border-radius:16px;box-shadow:0 12px 30px rgba(0,0,0,.4)}
    .hud{position:fixed;top:10px;left:50%;transform:translateX(-50%);display:flex;gap:18px;font-weight:700}
    .btn{position:fixed;bottom:14px;left:50%;transform:translateX(-50%);background:#3b82f6;border:none;color:#fff;
         padding:10px 16px;border-radius:999px;cursor:pointer}
    .tip{position:fixed;bottom:14px;right:14px;opacity:.7;font-size:12px}
  </style>
</head>
<body>
  <div class="hud"><div>Score: <span id="score">0</span></div><div>Lives: <span id="lives">3</span></div></div>
  <div id="wrap"><canvas id="game" width="480" height="720"></canvas></div>
  <button id="restart" class="btn" hidden>Tap/Click to Restart</button>
  <div class="tip">Move: ← → or A/D • Shoot: Space / Tap</div>

<script>
/* ================== CONFIG ================== */
const PLAYER_IMG_URL = "https://upload.wikimedia.org/wikipedia/commons/thumb/5/59/Star_icon-72a7cf.svg/256px-Star_icon-72a7cf.svg.png"; 
// ↑ Replace with your image URL. 48–80 px square works great.

/* ============= setup & utilities ============ */
const c = document.getElementById('game'), g = c.getContext('2d');
const scoreEl = document.getElementById('score'), livesEl = document.getElementById('lives');
const restartBtn = document.getElementById('restart');

const rand = (a,b)=> a + Math.random()*(b-a);
const clamp = (v,a,b)=> Math.max(a, Math.min(b,v));

let keys = {};
addEventListener('keydown', e=> keys[e.key.toLowerCase()] = true);
addEventListener('keyup',   e=> keys[e.key.toLowerCase()] = false);

let pointerDown = false;
addEventListener('pointerdown', ()=> { pointerDown = true; });
addEventListener('pointerup',   ()=> { pointerDown = false; });

/* ================ assets ==================== */
const playerImg = new Image();
playerImg.src = PLAYER_IMG_URL;
let playerImgReady = false;
playerImg.onload = ()=> playerImgReady = true;

/* ================ game state ================ */
const S = {
  running:false, score:0, lives:3, tick:0,
  player: { x:c.width/2, y:c.height-80, w:56, h:56, speed:4.2, cooldown:0 },
  bullets: [],
  enemies: [],
  enemyBullets: [], // (not used in this minimal version—kept for easy extension)
};

function reset(){
  S.running = true; S.score = 0; S.lives = 3; S.tick = 0;
  S.player.x = c.width/2; S.player.y = c.height-80; S.player.cooldown = 0;
  S.bullets.length = 0; S.enemies.length = 0; S.enemyBullets.length = 0;
  spawnWave();
  scoreEl.textContent = S.score; livesEl.textContent = S.lives;
  restartBtn.hidden = true;
}
function endGame(){
  S.running = false;
  restartBtn.hidden = false;
}

/* ================ entities ================== */
function shoot(){
  if (S.player.cooldown > 0) return;
  S.bullets.push({ x:S.player.x, y:S.player.y-28, vy:-8, r:3 });
  S.player.cooldown = 10; // frames
}

function spawnWave(){
  // simple 5x3 grid that drifts left-right & down slightly over time
  const rows = 3, cols = 7;
  const startX = 40, startY = 80, gapX = 56, gapY = 48;
  for (let r=0;r<rows;r++){
    for (let ccol=0; ccol<cols; ccol++){
      S.enemies.push({
        x: startX + ccol*gapX,
        y: startY + r*gapY,
        w: 32, h: 24,
        alive: true,
        baseX: startX + ccol*gapX,
        baseY: startY + r*gapY,
      });
    }
  }
}

/* ================ collisions ================ */
function rectHit(ax,ay,aw,ah,bx,by,bw,bh){
  return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
}

/* ================== loop ==================== */
function update(){
  S.tick++;

  // input
  const left = keys['arrowleft'] || keys['a'];
  const right= keys['arrowright']|| keys['d'];
  const shootKey = keys[' '] || keys['space'];
  const move = (right?1:0) - (left?1:0);
  S.player.x = clamp(S.player.x + move * S.player.speed, 24, c.width-24);

  // mobile tap: auto-shoot; horizontal drag bias not added for simplicity
  if (pointerDown) shoot();

  if (shootKey) shoot();
  if (S.player.cooldown>0) S.player.cooldown--;

  // update bullets
  for(const b of S.bullets) b.y += b.vy;
  // trim offscreen
  S.bullets = S.bullets.filter(b => b.y > -20);

  // enemy swarm movement (sinusoidal left-right, slow descent)
  const amp = 20 + Math.min(S.tick/10, 40);
  const speed = 0.5 + Math.min(S.tick/600, 1.2);
  for (const e of S.enemies){
    const phase = (e.baseX + e.baseY)*0.01;
    e.x = e.baseX + Math.sin(S.tick*0.03 + phase)*amp;
    e.y = e.baseY + Math.sin(S.tick*0.015 + phase*0.7)*4 + (S.tick*0.02*speed);
    // lose if they reach player line
    if (e.y + e.h >= S.player.y - 8) { S.lives = 0; livesEl.textContent = S.lives; endGame(); }
  }

  // bullet vs enemy
  for (const b of S.bullets){
    for (const e of S.enemies){
      if (!e.alive) continue;
      if (rectHit(b.x-2,b.y-6,4,12, e.x,e.y,e.w,e.h)){
        e.alive = false; b.y = -9999; // mark bullet for removal
        S.score += 10; scoreEl.textContent = S.score;
      }
    }
  }
  S.enemies = S.enemies.filter(e => e.alive);

  // win wave -> spawn next (faster drift because tick keeps rising)
  if (S.enemies.length === 0) spawnWave();
}

function draw(){
  g.clearRect(0,0,c.width,c.height);

  // starfield
  g.globalAlpha = .2; g.fillStyle = "#8fb3ff";
  for (let i=0;i<60;i++){ g.fillRect((i*53 + (S.tick*0.6 % 53))%c.width, (i*97 + S.tick*0.9)%c.height, 2,2); }
  g.globalAlpha = 1;

  // player
  if (playerImgReady){
    const p = S.player;
    g.drawImage(playerImg, p.x - p.w/2, p.y - p.h/2, p.w, p.h);
  } else {
    // fallback triangle
    const p = S.player;
    g.fillStyle = "#97e4ff";
    g.beginPath();
    g.moveTo(p.x, p.y-24); g.lineTo(p.x-20, p.y+22); g.lineTo(p.x+20, p.y+22); g.closePath(); g.fill();
  }

  // bullets
  g.fillStyle = "#ffd166";
  for (const b of S.bullets){ g.fillRect(b.x-2, b.y-8, 4, 12); }

  // enemies
  g.fillStyle = "#ff7a7a";
  for (const e of S.enemies){ g.fillRect(e.x, e.y, e.w, e.h); }
}

function loop(){
  if (!S.running) return;
  update(); draw();
  requestAnimationFrame(loop);
}

/* =============== boot =============== */
function start(){
  reset();
  loop();
}
const kick = () => { if (!S.running) start(); };
addEventListener('keydown', kick);
addEventListener('pointerdown', kick);

restartBtn.addEventListener('click', ()=> { start(); });

// start on first interaction
</script>
</body>
</html>
