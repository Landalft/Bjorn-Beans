<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Bjorn Beans – Tiny Galaxy Shooter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body{margin:0;height:100%;background:#0e1020;color:#fff;font-family:system-ui,Arial}
    #wrap{display:grid;place-items:center;height:100%}
    canvas{background:#0c1330;border:2px solid #3b82f6;border-radius:16px;box-shadow:0 12px 30px rgba(0,0,0,.4)}
    .hud{position:fixed;top:10px;left:50%;transform:translateX(-50%);display:flex;gap:18px;font-weight:700}
    .btn{position:fixed;bottom:14px;left:50%;transform:translateX(-50%);background:#3b82f6;border:none;color:#fff;
         padding:10px 16px;border-radius:999px;cursor:pointer}
    .tip{position:fixed;bottom:14px;right:14px;opacity:.75;font-size:12px}
  </style>
</head>
<body>
  <div class="hud"><div>Score: <span id="score">0</span></div><div>Lives: <span id="lives">3</span></div></div>
  <div id="wrap"><canvas id="game" width="480" height="720"></canvas></div>
  <button id="restart" class="btn" hidden>Tap/Click to Restart</button>
  <div class="tip">Move: ← → or A/D • Shoot: Space / Tap</div>

<script>
/* ================== CONFIG ================== */
/* Ship image: upload a file named ship.png to the repo root (or change the path) */
const PLAYER_IMG_SRC = "./ship.png";

/* Bean bullets:
   - default uses a built-in SVG (no extra file needed)
   - to use your own image, put bean.png in repo root and set BEAN_IMG_SRC = "./bean.png"
*/
const BEAN_IMG_SRC = ""; // set to "./bean.png" if you upload one
const BEAN_SVG = `
<svg xmlns='http://www.w3.org/2000/svg' width='32' height='48' viewBox='0 0 32 48'>
  <defs>
    <linearGradient id='g' x1='0' y1='0' x2='0' y2='1'>
      <stop offset='0' stop-color='#7b3f00'/>
      <stop offset='1' stop-color='#b5651d'/>
    </linearGradient>
  </defs>
  <ellipse cx='16' cy='24' rx='10' ry='16' fill='url(#g)'/>
  <ellipse cx='12' cy='16' rx='4' ry='6' fill='rgba(255,255,255,0.25)'/>
</svg>`;

/* ============= setup & utilities ============ */
const c = document.getElementById('game'), g = c.getContext('2d');
const scoreEl = document.getElementById('score'), livesEl = document.getElementById('lives');
const restartBtn = document.getElementById('restart');

const rand = (a,b)=> a + Math.random()*(b-a);
const clamp = (v,a,b)=> Math.max(a, Math.min(b,v));

let keys = {};
addEventListener('keydown', e=> keys[e.key.toLowerCase()] = true);
addEventListener('keyup',   e=> keys[e.key.toLowerCase()] = false);

let pointerDown = false;
addEventListener('pointerdown', ()=> { pointerDown = true; });
addEventListener('pointerup',   ()=> { pointerDown = false; });

/* ================ assets ==================== */
const shipImg = new Image(); shipImg.src = PLAYER_IMG_SRC;
let shipReady = false; shipImg.onload = ()=> shipReady = true;

const beanImg = new Image();
const beanURL = BEAN_IMG_SRC || ('data:image/svg+xml;utf8,' + encodeURIComponent(BEAN_SVG));
beanImg.src = beanURL;
let beanReady = false; beanImg.onload = ()=> beanReady = true;

/* ============ HiDPI crispness (optional) ============ */
(function scaleForDPR(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const w = c.width, h=c.height;
  c.width = w*dpr; c.height = h*dpr; c.style.width = w+"px"; c.style.height = h+"px";
  g.setTransform(dpr,0,0,dpr,0,0);
})();

/* ================ game state ================ */
const S = {
  running:false, score:0, lives:3, tick:0,
  player: { x:c.width/2, y:680, w:56, h:56, speed:4.2, cooldown:0 },
  bullets: [],
  enemies: [],
};

function reset(){
  S.running = true; S.score = 0; S.lives = 3; S.tick = 0;
  S.player.x = c.width/2; S.player.y = 680; S.player.cooldown = 0;
  S.bullets.length = 0; S.enemies.length = 0;
  spawnWave();
  scoreEl.textContent = S.score; livesEl.textContent = S.lives;
  restartBtn.hidden = true;
}
function endGame(){ S.running = false; restartBtn.hidden = false; }

/* ================ entities ================== */
function shoot(){
  if (S.player.cooldown > 0) return;
  const bw = 14, bh = 22;
  S.bullets.push({ x:S.player.x - bw/2, y:S.player.y - 34, vy:-8, w:bw, h:bh });
  S.player.cooldown = 9; // frames
}
function spawnWave(){
  // simple grid of enemies that drift L/R & slowly descend
  const rows = 3, cols = 7, startX = 40, startY = 80, gapX = 56, gapY = 48;
  for (let r=0;r<rows;r++){
    for (let ccol=0; ccol<cols; ccol++){
      S.enemies.push({
        x: startX + ccol*gapX,
        y: startY + r*gapY,
        w: 32, h: 24, alive: true,
        baseX: startX + ccol*gapX,
        baseY: startY + r*gapY,
      });
    }
  }
}

/* ================ collisions ================ */
function rectHit(ax,ay,aw,ah,bx,by,bw,bh){
  return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
}

/* ================== loop ==================== */
function update(){
  S.tick++;

  // input
  const left = keys['arrowleft'] || keys['a'];
  const right= keys['arrowright']|| keys['d'];
  const shootKey = keys[' '] || keys['space'];
  const move = (right?1:0) - (left?1:0);
  S.player.x = clamp(S.player.x + move * S.player.speed, 24, c.width-24);

  if (pointerDown) shoot();
  if (shootKey) shoot();
  if (S.player.cooldown>0) S.player.cooldown--;

  // update bullets
  for(const b of S.bullets){ b.y += b.vy; }
  S.bullets = S.bullets.filter(b => b.y > -40);

  // enemy swarm movement (sinusoidal L/R + gentle descent)
  const amp = 20 + Math.min(S.tick/10, 40);
  const speed = 0.5 + Math.min(S.tick/600, 1.2);
  for (const e of S.enemies){
    const phase = (e.baseX + e.baseY)*0.01;
    e.x = e.baseX + Math.sin(S.tick*0.03 + phase)*amp;
    e.y = e.baseY + Math.sin(S.tick*0.015 + phase*0.7)*4 + (S.tick*0.02*speed);
    if (e.y + e.h >= S.player.y - 8) { S.lives = 0; livesEl.textContent = S.lives; endGame(); }
  }

  // bullet vs enemy
  for (const b of S.bullets){
    for (const e of S.enemies){
      if (!e.alive) continue;
      if (rectHit(b.x,b.y,b.w,b.h, e.x,e.y,e.w,e.h)){
        e.alive = false; b.y = -9999;
        S.score += 10; scoreEl.textContent = S.score;
      }
    }
  }
  S.enemies = S.enemies.filter(e => e.alive);

  // next wave
  if (S.enemies.length === 0) spawnWave();
}

function draw(){
  g.clearRect(0,0,c.width,c.height);

  // starfield
  g.globalAlpha = .2; g.fillStyle = "#8fb3ff";
  for (let i=0;i<60;i++){ g.fillRect((i*53 + (S.tick*0.6 % 53))%c.width, (i*97 + S.tick*0.9)%c.height, 2,2); }
  g.globalAlpha = 1;

  // ship (image) with fallback triangle if image hasn't loaded
  const p = S.player;
  if (shipReady){
    g.drawImage(shipImg, p.x - p.w/2, p.y - p.h/2, p.w, p.h);
  } else {
    g.fillStyle = "#97e4ff";
    g.beginPath(); g.moveTo(p.x, p.y-24); g.lineTo(p.x-20, p.y+22); g.lineTo(p.x+20, p.y+22); g.closePath(); g.fill();
  }

  // bean bullets (image) with fallback rectangles
  for (const b of S.bullets){
    if (beanReady){
      g.drawImage(beanImg, b.x, b.y, b.w, b.h);
    } else {
      g.fillStyle = "#ffd166"; g.fillRect(b.x, b.y, b.w, b.h);
    }
  }

  // enemies (simple rectangles)
  g.fillStyle = "#ff7a7a";
  for (const e of S.enemies){ g.fillRect(e.x, e.y, e.w, e.h); }
}

function loop(){ if (!S.running) return; update(); draw(); requestAnimationFrame(loop); }

/* =============== boot =============== */
function start(){ reset(); loop(); }
const kick = () => { if (!S.running) start(); };
addEventListener('keydown', kick);
addEventListener('pointerdown', kick);
restartBtn.addEventListener('click', ()=> { start(); });
</script>
</body>
</html>
